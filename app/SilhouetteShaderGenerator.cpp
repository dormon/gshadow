#include"SilhouetteShaderGenerator.h"

#include<sstream>

std::string TranslateShaderProfile(enum EShaderProfile Profile){
  switch(Profile){
    case COMPATIBILITY:return"compatibility";break;
    case CORE:return"core";break;
    case ES:return"es";break;
    case NOTHING:
    default:return"";break;
  }
}

namespace NGeometrySilhouetteShader{
  const std::string GeometryPrologue=
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Options:\n"
    "// if you define something, it will be applied.\n"
    "// if you don't define something, opposite will be applied.\n"
    "// Some defines has value that has to be set properly.\n"
    "// Version number has to be chosen by user, preprocessor\n"
    "// cannot do it (nothing useful can precede #version N P).\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n";

  const std::string GeometryEpilogue=
    "\n"
    "// DO NOT CHANGE ANYTHING BELOW THIS COMMENT!!!\n"
    "// UNLESS, OF COURSE, YOU KNOW WHAT YOU ARE DOING.\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// TODO extensions and checks\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "#if __VERSION__ < 330\n"
    "  #extension GL_EXT_geometry_shader4:enable\n"
    "#endif\n"
    "\n"
    "#if MATRIX == gl_ModelViewProjectionMatrix && __VERSION__ >= 150\n"
    "  #if GL_compatibility_profile != 1\n"
    "    #error gl_ModelViewProjectionMatrix requiers\\\n"
    "    compatibility after version 140\n"
    "  #endif\n"
    "#endif\n"
    "\n"
    "#if MAX_MULTIPLICITY > 16\n"
    "  #error Max Multiplicity cannot exceed 16\n"
    "#endif\n"
    "\n"
    "#if MAX_MULTIPLICITY < 1\n"
    "  #error Max Multiplicity cannont be 0 or less\n"
    "#endif\n"
    "\n"
    "#ifdef FRONT_CAP_TO_INFINITY\n"
    "  #define SWIZZLE xyww\n"
    "#else\n"
    "  #define SWIZZLE xyzw\n"
    "#endif\n"
    "\n"
    "//TODO Vertex Attrib Array\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// compute indices of vertices of side and caps\n"
    "// multiplicity is computed using CCW no matter what\n"
    "\n"
    "// header of next table\n"
    "// FRONT_FACE_INSIDE\n"
    "// CCW_IS_FRONT_FACE\n"
    "// Multiplicity possitive indices\n"
    "// Multiplicity negative indices\n"
    "// Stencil Value Export indices\n"
    "//\n"
    "// SIDES:\n"
    "// FFI CCW | PS   NS    SVE\n"
    "//   0   0 | 0123 1032  0123\n"
    "//   0   1 | 1032 0123  1032\n"
    "//   1   0 | 1032 0123  1032\n"
    "//   1   1 | 0123 1023  0123\n"
    "//\n"
    "// CAPS:\n"
    "// FFI CCW | PFC PBC NFC NBC  SVE\n"
    "//   0   0 | 10i 23i 01i 32i  10i 23i\n"
    "//   0   1 | 01i 32i 10i 23i  01i 32i\n"
    "//   1   0 | 01i 32i 10i 23i  01i 32i\n"
    "//   1   1 | 10i 23i 01i 32i  10i 23i\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "//SIDES indices\n"
    "#if defined(FRONT_FACE_INSIDE) ^ defined(CCW_IS_FRONT_FACE)\n"
    "  //possitive multiplicity - Side index\n"
    "  #define PS0 1\n"
    "  #define PS1 0\n"
    "  #define PS2 3\n"
    "  #define PS3 2\n"
    "  //negative multiplicity - Side index\n"
    "  #define NS0 0\n"
    "  #define NS1 1\n"
    "  #define NS2 2\n"
    "  #define NS3 3\n"
    "#else\n"
    "  //possitive multiplicity - Side index\n"
    "  #define PS0 0\n"
    "  #define PS1 1\n"
    "  #define PS2 2\n"
    "  #define PS3 3\n"
    "  //negative multiplicity - Side index\n"
    "  #define NS0 1\n"
    "  #define NS1 0\n"
    "  #define NS2 3\n"
    "  #define NS3 2\n"
    "#endif//defined(FRONT_FACE_INSIDE) ^ defined(CCW_IS_FRONT_FACE)\n"
    "\n"
    "//CAPS indices\n"
    "#if defined(FRONT_FACE_INSIDE) ^ defined(CCW_IS_FRONT_FACE)\n"
    "  //possitive multiplicity - Front Cap index\n"
    "  #define PFC0 0\n"
    "  #define PFC1 1\n"
    "  #define PFC2 i\n"
    "  //possitive multiplicity - Back Cap index\n"
    "  #define PBC0 3\n"
    "  #define PBC1 2\n"
    "  #define PBC2 i\n"
    "  //negative multiplicity - Front Cap index\n"
    "  #define NFC0 1\n"
    "  #define NFC1 0\n"
    "  #define NFC2 i\n"
    "  //negative multiplicity - Back Cap index\n"
    "  #define NBC0 2\n"
    "  #define NBC1 3\n"
    "  #define NBC2 i\n"
    "#else\n"
    "  //possitive multiplicity - Front Cap index\n"
    "  #define PFC0 1\n"
    "  #define PFC1 0\n"
    "  #define PFC2 i\n"
    "  //possitive multiplicity - Back Cap index\n"
    "  #define PBC0 2\n"
    "  #define PBC1 3\n"
    "  #define PBC2 i\n"
    "  //negative multiplicity - Front Cap index\n"
    "  #define NFC0 0\n"
    "  #define NFC1 1\n"
    "  #define NFC2 i\n"
    "  //negative multiplicity - Back Cap index\n"
    "  #define NBC0 3\n"
    "  #define NBC1 2\n"
    "  #define NBC2 i\n"
    "#endif//defined(FRONT_FACE_INSIDE) ^ defined(CCW_IS_FRONT_FACE)\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// compute max_vertices\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "/*\n"
    "#!/bin/python\n"
    "\n"
    "MAX_MULTIPLICITY = 16\n"
    "\n"
    "def PrintList(l):\n"
    "  for idx,e in enumerate(l):\n"
    "    if idx==0:\n"
    "      print \"      #if   MAX_MULTIPLICITY==\",idx+1\n"
    "      print \"        #define MAX_VERTICES \",e\n"
    "    else:\n"
    "      print \"      #elif MAX_MULTIPLICITY==\",idx+1\n"
    "      print \"        #define MAX_VERTICES \",e\n"
    "  print     \"      #endif\"\n"
    "\n"
    "print \"\"\"#ifdef USE_STENCIL_VALUE_EXPORT\n"
    "  #ifdef GENERATE_SIDES\n"
    "    #ifdef GENERATE_CAPS\n"
    "      //sides and caps\"\"\"\n"
    "PrintList([4+i*2*3 for i in range(1,MAX_MULTIPLICITY+1)])\n"
    "print \"\"\"    #else\n"
    "      //sides only\n"
    "      #define MAX_VERTICES 4\n"
    "    #endif//GENERATE_CAPS\n"
    "  #else\n"
    "    #ifdef GENERATE_CAPS\n"
    "      //caps only\"\"\"\n"
    "PrintList([i*2*3 for i in range(1,MAX_MULTIPLICITY+1)])\n"
    "print \"\"\"    #else\n"
    "      #error Sides or caps have to be generated!\n"
    "    #endif//GENERATE_CAPS\n"
    "  #endif//GENERATE_SIDES\n"
    "#else\n"
    "  #ifdef GENERATE_SIDES\n"
    "    #ifdef GENERATE_CAPS\n"
    "      //sides and caps\"\"\"\n"
    "PrintList([4*i+i*2*3 for i in range(1,MAX_MULTIPLICITY+1)])\n"
    "print \"\"\"    #else\n"
    "      //sides only\"\"\"\n"
    "PrintList([4*i for i in range(1,MAX_MULTIPLICITY+1)])\n"
    "print \"\"\"    #endif//GENERATE_CAPS\n"
    "  #else\n"
    "    #ifdef GENERATE_CAPS\n"
    "      //caps only\"\"\"\n"
    "PrintList([i*2*3 for i in range(1,MAX_MULTIPLICITY+1)])\n"
    "print \"\"\"    #else\n"
    "      #error Sides or caps have to be generated!\n"
    "    #endif//GENERATE_CAPS\n"
    "  #endif//GENERATE_SIDES\n"
    "#endif//USE_STENCIL_VALUE_EXPORT\n"
    "\"\"\"\n"
    "*/\n"
    "\n"
    "#ifdef USE_STENCIL_VALUE_EXPORT\n"
    "  #ifdef GENERATE_SIDES\n"
    "    #ifdef GENERATE_CAPS\n"
    "      //sides and caps\n"
    "      #if   MAX_MULTIPLICITY== 1\n"
    "        #define MAX_VERTICES  10\n"
    "      #elif MAX_MULTIPLICITY== 2\n"
    "        #define MAX_VERTICES  16\n"
    "      #elif MAX_MULTIPLICITY== 3\n"
    "        #define MAX_VERTICES  22\n"
    "      #elif MAX_MULTIPLICITY== 4\n"
    "        #define MAX_VERTICES  28\n"
    "      #elif MAX_MULTIPLICITY== 5\n"
    "        #define MAX_VERTICES  34\n"
    "      #elif MAX_MULTIPLICITY== 6\n"
    "        #define MAX_VERTICES  40\n"
    "      #elif MAX_MULTIPLICITY== 7\n"
    "        #define MAX_VERTICES  46\n"
    "      #elif MAX_MULTIPLICITY== 8\n"
    "        #define MAX_VERTICES  52\n"
    "      #elif MAX_MULTIPLICITY== 9\n"
    "        #define MAX_VERTICES  58\n"
    "      #elif MAX_MULTIPLICITY== 10\n"
    "        #define MAX_VERTICES  64\n"
    "      #elif MAX_MULTIPLICITY== 11\n"
    "        #define MAX_VERTICES  70\n"
    "      #elif MAX_MULTIPLICITY== 12\n"
    "        #define MAX_VERTICES  76\n"
    "      #elif MAX_MULTIPLICITY== 13\n"
    "        #define MAX_VERTICES  82\n"
    "      #elif MAX_MULTIPLICITY== 14\n"
    "        #define MAX_VERTICES  88\n"
    "      #elif MAX_MULTIPLICITY== 15\n"
    "        #define MAX_VERTICES  94\n"
    "      #elif MAX_MULTIPLICITY== 16\n"
    "        #define MAX_VERTICES  100\n"
    "      #endif\n"
    "    #else\n"
    "      //sides only\n"
    "      #define MAX_VERTICES 4\n"
    "    #endif//GENERATE_CAPS\n"
    "  #else\n"
    "    #ifdef GENERATE_CAPS\n"
    "      //caps only\n"
    "      #if   MAX_MULTIPLICITY== 1\n"
    "        #define MAX_VERTICES  6\n"
    "      #elif MAX_MULTIPLICITY== 2\n"
    "        #define MAX_VERTICES  12\n"
    "      #elif MAX_MULTIPLICITY== 3\n"
    "        #define MAX_VERTICES  18\n"
    "      #elif MAX_MULTIPLICITY== 4\n"
    "        #define MAX_VERTICES  24\n"
    "      #elif MAX_MULTIPLICITY== 5\n"
    "        #define MAX_VERTICES  30\n"
    "      #elif MAX_MULTIPLICITY== 6\n"
    "        #define MAX_VERTICES  36\n"
    "      #elif MAX_MULTIPLICITY== 7\n"
    "        #define MAX_VERTICES  42\n"
    "      #elif MAX_MULTIPLICITY== 8\n"
    "        #define MAX_VERTICES  48\n"
    "      #elif MAX_MULTIPLICITY== 9\n"
    "        #define MAX_VERTICES  54\n"
    "      #elif MAX_MULTIPLICITY== 10\n"
    "        #define MAX_VERTICES  60\n"
    "      #elif MAX_MULTIPLICITY== 11\n"
    "        #define MAX_VERTICES  66\n"
    "      #elif MAX_MULTIPLICITY== 12\n"
    "        #define MAX_VERTICES  72\n"
    "      #elif MAX_MULTIPLICITY== 13\n"
    "        #define MAX_VERTICES  78\n"
    "      #elif MAX_MULTIPLICITY== 14\n"
    "        #define MAX_VERTICES  84\n"
    "      #elif MAX_MULTIPLICITY== 15\n"
    "        #define MAX_VERTICES  90\n"
    "      #elif MAX_MULTIPLICITY== 16\n"
    "        #define MAX_VERTICES  96\n"
    "      #endif\n"
    "    #else\n"
    "      #error Sides or caps have to be generated!\n"
    "    #endif//GENERATE_CAPS\n"
    "  #endif//GENERATE_SIDES\n"
    "#else\n"
    "  #ifdef GENERATE_SIDES\n"
    "    #ifdef GENERATE_CAPS\n"
    "      //sides and caps\n"
    "      #if   MAX_MULTIPLICITY== 1\n"
    "        #define MAX_VERTICES  10\n"
    "      #elif MAX_MULTIPLICITY== 2\n"
    "        #define MAX_VERTICES  20\n"
    "      #elif MAX_MULTIPLICITY== 3\n"
    "        #define MAX_VERTICES  30\n"
    "      #elif MAX_MULTIPLICITY== 4\n"
    "        #define MAX_VERTICES  40\n"
    "      #elif MAX_MULTIPLICITY== 5\n"
    "        #define MAX_VERTICES  50\n"
    "      #elif MAX_MULTIPLICITY== 6\n"
    "        #define MAX_VERTICES  60\n"
    "      #elif MAX_MULTIPLICITY== 7\n"
    "        #define MAX_VERTICES  70\n"
    "      #elif MAX_MULTIPLICITY== 8\n"
    "        #define MAX_VERTICES  80\n"
    "      #elif MAX_MULTIPLICITY== 9\n"
    "        #define MAX_VERTICES  90\n"
    "      #elif MAX_MULTIPLICITY== 10\n"
    "        #define MAX_VERTICES  100\n"
    "      #elif MAX_MULTIPLICITY== 11\n"
    "        #define MAX_VERTICES  110\n"
    "      #elif MAX_MULTIPLICITY== 12\n"
    "        #define MAX_VERTICES  120\n"
    "      #elif MAX_MULTIPLICITY== 13\n"
    "        #define MAX_VERTICES  130\n"
    "      #elif MAX_MULTIPLICITY== 14\n"
    "        #define MAX_VERTICES  140\n"
    "      #elif MAX_MULTIPLICITY== 15\n"
    "        #define MAX_VERTICES  150\n"
    "      #elif MAX_MULTIPLICITY== 16\n"
    "        #define MAX_VERTICES  160\n"
    "      #endif\n"
    "    #else\n"
    "      //sides only\n"
    "      #if   MAX_MULTIPLICITY== 1\n"
    "        #define MAX_VERTICES  4\n"
    "      #elif MAX_MULTIPLICITY== 2\n"
    "        #define MAX_VERTICES  8\n"
    "      #elif MAX_MULTIPLICITY== 3\n"
    "        #define MAX_VERTICES  12\n"
    "      #elif MAX_MULTIPLICITY== 4\n"
    "        #define MAX_VERTICES  16\n"
    "      #elif MAX_MULTIPLICITY== 5\n"
    "        #define MAX_VERTICES  20\n"
    "      #elif MAX_MULTIPLICITY== 6\n"
    "        #define MAX_VERTICES  24\n"
    "      #elif MAX_MULTIPLICITY== 7\n"
    "        #define MAX_VERTICES  28\n"
    "      #elif MAX_MULTIPLICITY== 8\n"
    "        #define MAX_VERTICES  32\n"
    "      #elif MAX_MULTIPLICITY== 9\n"
    "        #define MAX_VERTICES  36\n"
    "      #elif MAX_MULTIPLICITY== 10\n"
    "        #define MAX_VERTICES  40\n"
    "      #elif MAX_MULTIPLICITY== 11\n"
    "        #define MAX_VERTICES  44\n"
    "      #elif MAX_MULTIPLICITY== 12\n"
    "        #define MAX_VERTICES  48\n"
    "      #elif MAX_MULTIPLICITY== 13\n"
    "        #define MAX_VERTICES  52\n"
    "      #elif MAX_MULTIPLICITY== 14\n"
    "        #define MAX_VERTICES  56\n"
    "      #elif MAX_MULTIPLICITY== 15\n"
    "        #define MAX_VERTICES  60\n"
    "      #elif MAX_MULTIPLICITY== 16\n"
    "        #define MAX_VERTICES  64\n"
    "      #endif\n"
    "    #endif//GENERATE_CAPS\n"
    "  #else\n"
    "    #ifdef GENERATE_CAPS\n"
    "      //caps only\n"
    "      #if   MAX_MULTIPLICITY== 1\n"
    "        #define MAX_VERTICES  6\n"
    "      #elif MAX_MULTIPLICITY== 2\n"
    "        #define MAX_VERTICES  12\n"
    "      #elif MAX_MULTIPLICITY== 3\n"
    "        #define MAX_VERTICES  18\n"
    "      #elif MAX_MULTIPLICITY== 4\n"
    "        #define MAX_VERTICES  24\n"
    "      #elif MAX_MULTIPLICITY== 5\n"
    "        #define MAX_VERTICES  30\n"
    "      #elif MAX_MULTIPLICITY== 6\n"
    "        #define MAX_VERTICES  36\n"
    "      #elif MAX_MULTIPLICITY== 7\n"
    "        #define MAX_VERTICES  42\n"
    "      #elif MAX_MULTIPLICITY== 8\n"
    "        #define MAX_VERTICES  48\n"
    "      #elif MAX_MULTIPLICITY== 9\n"
    "        #define MAX_VERTICES  54\n"
    "      #elif MAX_MULTIPLICITY== 10\n"
    "        #define MAX_VERTICES  60\n"
    "      #elif MAX_MULTIPLICITY== 11\n"
    "        #define MAX_VERTICES  66\n"
    "      #elif MAX_MULTIPLICITY== 12\n"
    "        #define MAX_VERTICES  72\n"
    "      #elif MAX_MULTIPLICITY== 13\n"
    "        #define MAX_VERTICES  78\n"
    "      #elif MAX_MULTIPLICITY== 14\n"
    "        #define MAX_VERTICES  84\n"
    "      #elif MAX_MULTIPLICITY== 15\n"
    "        #define MAX_VERTICES  90\n"
    "      #elif MAX_MULTIPLICITY== 16\n"
    "        #define MAX_VERTICES  96\n"
    "      #endif\n"
    "    #else\n"
    "      #error Sides or caps have to be generated!\n"
    "    #endif//GENERATE_CAPS\n"
    "  #endif//GENERATE_SIDES\n"
    "#endif//USE_STENCIL_VALUE_EXPORT\n"
    "\n"
    "layout(points)in;\n"
    "layout(triangle_strip,max_vertices=MAX_VERTICES)out;\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Uniforms\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "#ifdef MATRIX\n"
    "uniform mat4 MATRIX;\n"
    "#else\n"
    "  #define MATRIX gl_ModelViewProjectionMatrix\n"
    "#endif\n"
    "\n"
    "uniform vec4 LIGHT;\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Inputs from vertex shader\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "#ifdef USE_ARRAY_TRANSFER\n"
    "in Opposite{vec4 Vertex[MAX_MULTIPLICITY];}O[];\n"
    "#else\n"
    "  #define DEF_INPUT(x) in vec4 vOpposite##x[];\n"
    "  #if MAX_MULTIPLICITY>0\n"
    "    DEF_INPUT(0)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>1\n"
    "    DEF_INPUT(1)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>2\n"
    "    DEF_INPUT(2)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>3\n"
    "    DEF_INPUT(3)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>4\n"
    "    DEF_INPUT(4)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>5\n"
    "    DEF_INPUT(5)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>6\n"
    "    DEF_INPUT(6)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>7\n"
    "    DEF_INPUT(7)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>8\n"
    "    DEF_INPUT(8)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>9\n"
    "    DEF_INPUT(9)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>10\n"
    "    DEF_INPUT(10)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>11\n"
    "    DEF_INPUT(11)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>12\n"
    "    DEF_INPUT(12)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>13\n"
    "    DEF_INPUT(13)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>14\n"
    "    DEF_INPUT(14)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>15\n"
    "    DEF_INPUT(15)\n"
    "  #endif\n"
    "#endif//USE_ARRAY_TRANSFER\n"
    "\n"
    "in vec4 vVertexB[];\n"
    "\n"
    "#ifdef UNIVERSAL\n"
    "in vec4 vNumberOfOppositeVertices[];\n"
    "#endif\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Outputs from geometry shader\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "#ifdef USE_STENCIL_VALUE_EXPORT\n"
    "flat out int gMultiplicity;\n"
    "#endif\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Functions\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "/**\n"
    "* @brief Computes greater vector\n"
    "*\n"
    "* @param a vertex a\n"
    "* @param b vertex b\n"
    "*\n"
    "* @return 1 if a>b, 0 if a==b, -1 if b<a\n"
    "*/\n"
    "int GreaterVec(in vec3 a,in vec3 b){\n"
    "  return int(dot(sign(a-b),vec3(4,2,1)));\n"
    "}\n"
    "\n"
    "#ifdef REFERENCE_EDGE\n"
    "/**\n"
    "* @brief Function computes multiplicity for one opposite vertex\n"
    "*\n"
    "* @param A smallest vertex of a triangle\n"
    "* @param B middle vertex of a triangle\n"
    "* @param C largest vertex of a triangle\n"
    "* @param L light position\n"
    "*\n"
    "* @return 1 ABC (CCW) facing L, -1 ABC (CCW) not-facing L\n"
    "*/\n"
    "int ComputeMult(in vec3 A,in vec3 B,in vec3 C,in vec4 L){\n"
    "  vec3 n=cross(C-A,L.xyz-A*L.w);//normal vector of light plane\n"
    "  return int(sign(dot(n,B-A)));//multiplicity\n"
    "}\n"
    "#endif//REFERENCE_EDGE\n"
    "\n"
    "#if defined(CULL_SIDES) &&defined(GENERATE_SIDES)\n"
    "/**\n"
    " * @brief Check if edge is visible\n"
    " *\n"
    " * @param A point A\n"
    " * @param B point B\n"
    " *\n"
    " * @return true -> edge is visible\n"
    " */\n"
    "bool IsEdgeVisible(in vec4 A,in vec4 B){\n"
    "  vec3 M=+A.xyz+A.www;\n"
    "  vec3 N=+B.xyz+B.www;\n"
    "  vec3 O=-A.xyz+A.www;\n"
    "  vec3 P=-B.xyz+B.www;\n"
    "  vec3 NM=N-M;\n"
    "  vec3 PO=P-O;\n"
    "  float Left=0;\n"
    "  float Right=1;\n"
    "  for(int i=0;i<3;++i){\n"
    "    if(NM[i]==0){\n"
    "      if(M[i]<0)return false;\n"
    "    }else{\n"
    "      if(NM[i]>0)Left=max(Left,-M[i]/NM[i]);\n"
    "      else Right=min(Right,-M[i]/NM[i]);\n"
    "    }\n"
    "                                              \n"
    "    if(PO[i]==0){\n"
    "      if(O[i]<0)return false;\n"
    "    }else{\n"
    "      if(PO[i]>0)Left=max(Left,-O[i]/PO[i]);\n"
    "      else Right=min(Right,-O[i]/PO[i]);\n"
    "    }\n"
    "  }\n"
    "  return Left<=Right;\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Checks if side covers fullscreen\n"
    " *\n"
    " * @param A point A\n"
    " * @param B vector B-A\n"
    " * @param C vector C-A\n"
    " * @param Diag diagonal id\n"
    " *\n"
    " * @return true -> side is visible\n"
    " */\n"
    "bool IsFullVisible(in vec4 A,in vec4 B,in vec4 C,int Diag){\n"
    "  vec3 a=A.xyz;\n"
    "  vec3 b=B.xyz;\n"
    "  vec3 c=C.xyz;\n"
    "  if(Diag>=0){\n"
    "    a[Diag]=-a[Diag];\n"
    "    b[Diag]=-b[Diag];\n"
    "    c[Diag]=-c[Diag];\n"
    "  }\n"
    "  float m=(a.x-a.y);\n"
    "  float n=(b.x-b.y);\n"
    "  float o=(c.x-c.y);\n"
    "  float p=(a.x-a.z);\n"
    "  float q=(b.x-b.z);\n"
    "  float r=(c.x-c.z);\n"
    "  float d=(q*o-n*r);\n"
    "  float t=(m*r-p*o)/d;\n"
    "  float l=-(m*q-p*n)/d;\n"
    "  vec4 X=A+t*B+l*C;\n"
    "  return (t>0)&&(t<1)&&(l>0)&&(l<1)&&\n"
    "      all(greaterThan(X.xyz,-X.www))&&all(lessThan(X.xyz,X.www));\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Check if side is visible\n"
    " *\n"
    " * @param P[4] points of side\n"
    " * @param Diag diagonal id\n"
    " *\n"
    " * @return true -> side is visible\n"
    " */\n"
    "bool IsVisible(in vec4 P[4],in int Diag){\n"
    "  if(IsFullVisible(P[0],P[1]-P[0],P[2]-P[0],Diag))return true;\n"
    "  if(IsEdgeVisible(P[0],P[1]))return true;\n"
    "  if(IsEdgeVisible(P[0],P[2]))return true;\n"
    "  if(IsEdgeVisible(P[1],P[3]))return true;\n"
    "  if(IsEdgeVisible(P[2],P[3]))return true;\n"
    "  return false;\n"
    "}\n"
    "#endif//defined(CULL_SIDES) &&defined(GENERATE_SIDES)\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Main function\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "void main(){\n"
    "  vec4 P[4];\n"
    "  P[0]=gl_in[0].gl_Position;\n"
    "  P[1]=vVertexB[0];\n"
    "  P[2]=vec4(P[0].xyz*LIGHT.w-LIGHT.xyz,0);\n"
    "  P[3]=vec4(P[1].xyz*LIGHT.w-LIGHT.xyz,0);\n"
    "\n"
    "#if defined(CULL_SIDES) && defined(GENERATE_SIDES)\n"
    "  vec4 ClipP[4];//clip space coords\n"
    "  for(int i=0;i<4;++i)\n"
    "    ClipP[i]=MATRIX*P[i];\n"
    "\n"
    "  vec3 Normal=(MATRIX*vec4(cross(\n"
    "      P[1].xyz-P[0].xyz,\n"
    "      LightPosition.xyz-P[0].xyz*LightPosition.w),0)).xyz;\n"
    "  ivec3 Corner=ivec3(1+sign(Normal))>>1;\n"
    "  if(Corner.z==1);Corner=ivec3(1)-Corner;\n"
    "  int Diag=Corner.x+(Corner.y<<1)-1;\n"
    "#endif//defined(CULL_SIDES) && defined(GENERATE_SIDES)\n"
    "\n"
    "#if defined(CULL_SIDES) && defined(GENERATE_SIDES)\n"
    "  #ifdef GENERATE_CAPS\n"
    "  bool NotCull=IsVisible(ClipP,Diag);\n"
    "  #else//GENERATE_CAPS\n"
    "  if(!IsVisible(ClipP,Diag))return;\n"
    "  #endif//GENERATE_CAPS\n"
    "#endif\n"
    "\n"
    "#ifndef USE_ARRAY_TRANSFER\n"
    "  #define DEF_FILL(x) O[##x##]=vOpposite##x[0];\n"
    "  vec4 O[MAX_MULTIPLICITY];\n"
    "   #if MAX_MULTIPLICITY>0\n"
    "    DEF_FILL(0)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>1\n"
    "    DEF_FILL(1)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>2\n"
    "    DEF_FILL(2)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>3\n"
    "    DEF_FILL(3)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>4\n"
    "    DEF_FILL(4)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>5\n"
    "    DEF_FILL(5)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>6\n"
    "    DEF_FILL(6)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>7\n"
    "    DEF_FILL(7)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>8\n"
    "    DEF_FILL(8)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>9\n"
    "    DEF_FILL(9)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>10\n"
    "    DEF_FILL(10)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>11\n"
    "    DEF_FILL(11)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>12\n"
    "    DEF_FILL(12)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>13\n"
    "    DEF_FILL(13)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>14\n"
    "    DEF_FILL(14)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>15\n"
    "    DEF_FILL(15)\n"
    "  #endif\n"
    "#endif//USE_ARRAY_TRANSFER\n"
    "\n"
    "#ifdef UNIVERSAL\n"
    "  int Num=int(vNumberOfOppositeVertices[0].x);\n"
    "#endif\n"
    "\n"
    "#ifdef GENERATE_SIDES\n"
    "  int Multiplicity=0;\n"
    "#endif//GENERATE_SIDES\n"
    "\n"
    "#ifdef UNIVERSAL\n"
    "  for(int i=0;i<Num;++i)\n"
    "#else\n"
    "  for(int i=0;i<MAX_MULTIPLICITY;++i)\n"
    "#endif//UNIVERSAL\n"
    "  {\n"
    "    int ActMultiplicity=0;//+1 (T0T1T2) CCW frontface L\n"
    "#define T0 P[0].xyz\n"
    "#define T1 P[1].xyz\n"
    "#ifdef USE_ARRAY_TRANSFER\n"
    "  #define T2 O[0].Vertex[i].xyz\n"
    "  #define ActOpposite O[0].Vertex[i]\n"
    "#else//USE_ARRAY_TRANSFER\n"
    "  #define T2 O[i].xyz\n"
    "  #define ActOpposite O[i]\n"
    "#endif//USE_ARRAY_TRANSFER\n"
    "\n"
    "#ifdef REFERENCE_EDGE\n"
    "  #ifdef DETERMINISTIC\n"
    "    if(GreaterVec(T0,T2)>0){//T[2] T[0] T[1]?\n"
    "      ActMultiplicity=+ComputeMult(T2,T0,T1,LightPosition);\n"
    "    }else{\n"
    "      if(GreaterVec(T1,T2)>0){//T[0] T[2] T[1]?\n"
    "        ActMultiplicity=-ComputeMult(T0,T2,T1,LightPosition);\n"
    "      }else{//T[0] T[1] T[2]?\n"
    "        ActMultiplicity=+ComputeMult(T0,T1,T2,LightPosition);\n"
    "      }\n"
    "    }\n"
    "  #else//NONDETERMINISTIC\n"
    "    ActMultiplicity=-ComputeMult(T0,T2,T1,LightPosition);\n"
    "  #endif//DETERMINISTIC\n"
    "#else//GRAPHICON\n"
    "  #ifdef DETERMINISTIC\n"
    "    vec3 T[3];\n"
    "    vec3 D[3];\n"
    "    vec3 NS[3];\n"
    "    vec4 PL[3];\n"
    "    float d[3];\n"
    "\n"
    "    D[0]=LIGHT.xyz-T0*LIGHT.w;//vector to the lights from T0\n"
    "    NS[0]=normalize(cross(T1-T0,D[0]));//normal vector of Light plane\n"
    "    PL[0]=vec4(NS[0],-dot(NS[0],T0));//light plane\n"
    "    d[0]=dot(PL[0],vec4(T2,1));//-1 if (T0T1T2) CCW is frontfacing L\n"
    "\n"
    "\n"
    "    D[1]=LIGHT.xyz-T1*LIGHT.w;\n"
    "    D[2]=LIGHT.xyz-T2*LIGHT.w;\n"
    "\n"
    "    if(GreaterVec(T2,T0)>0){\n"
    "      NS[1]=normalize(cross(T2-T0,D[0]));\n"
    "      PL[1]=vec4(NS[1],-dot(NS[1],T0));\n"
    "      d[1]=dot(PL[1],vec4(T1,1));\n"
    "    }else{\n"
    "      NS[1]=normalize(cross(T0-T2,D[2]));\n"
    "      PL[1]=vec4(NS[1],-dot(NS[1],T2));\n"
    "      d[1]=-dot(PL[1],vec4(T1,1));\n"
    "    }\n"
    "\n"
    "    if(GreaterVec(T2,T1)>0){\n"
    "      NS[2]=normalize(cross(T2-T1,D[1]));\n"
    "      PL[2]=vec4(NS[2],-dot(NS[2],T1));\n"
    "      d[2]=dot(PL[2],vec4(T0,1));\n"
    "    }else{\n"
    "      NS[2]=normalize(cross(T1-T2,D[2]));\n"
    "      PL[2]=vec4(NS[2],-dot(NS[2],T2));\n"
    "      d[2]=-dot(PL[2],vec4(T0,1));\n"
    "    }\n"
    "\n"
    "    if(d[0]==0||d[1]==0||d[2]==0)continue;\n"
    "    if(!((d[0]<0&&d[1]>0&&d[2]<0)||(d[0]>0&&d[1]<0&&d[2]>0)))continue;\n"
    "    ActMultiplicity=-int(sign(d[0]));\n"
    "  #else//NONDETERMINISTIC\n"
    "    vec3 D=LIGHT.xyz-T0*LIGHT.w;\n"
    "    vec3 NS=normalize(cross(T1-T0,D));\n"
    "    vec4 PL=vec4(NS,-dot(NS,T0));\n"
    "    float d=dot(PL,vec4(T2,1));//-1 if (T0T1T2) CCW is frontfacing L\n"
    "    ActMultiplicity=-int(sign(d));\n"
    "  #endif//DETERMINISTIC\n"
    "#endif//REFERENCE_EDGE\n"
    "\n"
    "#ifdef GENERATE_CAPS\n"
    "  if(ActMultiplicity!=0&&ActOpposite.w==1){\n"
    "  #ifdef USE_STENCIL_VALUE_EXPORT\n"
    "    #if defined(CULL_SIDES) && defined(GENERATE_SIDES)\n"
    "    //front cap\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=ClipP[PFC0].SWIZZLE;\n"
    "    EmitVertex();\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=ClipP[PFC1].SWIZZLE;\n"
    "    EmitVertex();\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=(MATRIX*ActOpposite).SWIZZLE;\n"
    "    EmitVertex();\n"
    "    EndPrimitive();\n"
    "    //back cap\n"
    "    gMultiplicity=ActMultiplicity;gl_Position=ClipP[PBC0];EmitVertex();\n"
    "    gMultiplicity=ActMultiplicity;gl_Position=ClipP[PBC1];EmitVertex();\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=MATRIX*vec4(ActOpposite.xyz*LIGHT.w-LIGHT.xyz,0);\n"
    "    EmitVertex();\n"
    "    EndPrimitive();\n"
    "    #else//defined(CULL_SIDES) && defined(GENERATE_SIDES)\n"
    "    //front cap\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=(MATRIX*P[PFC0]).SWIZZLE;\n"
    "    EmitVertex();\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=(MATRIX*P[PFC1]).SWIZZLE;\n"
    "    EmitVertex();\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=(MATRIX*ActOpposite).SWIZZLE;\n"
    "    EmitVertex();\n"
    "    EndPrimitive();\n"
    "    //back cap\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=MATRIX*P[PBC0];\n"
    "    EmitVertex();\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=MATRIX*P[PBC1];\n"
    "    EmitVertex();\n"
    "    gMultiplicity=ActMultiplicity;\n"
    "    gl_Position=MATRIX*vec4(ActOpposite.xyz*LIGHT.w-LIGHT.xyz,0);\n"
    "    EmitVertex();\n"
    "    EndPrimitive();\n"
    "    #endif//defined(CULL_SIDES) && defined(GENERATE_SIDES)\n"
    "  #else//USE_STENCIL_VALUE_EXPORT\n"
    "    #if defined(CULL_SIDES) && defined(GENERATE_SIDES)\n"
    "    if(ActMultiplicity>0){\n"
    "      //front cap\n"
    "      gl_Position=ClipP[PFC0].SWIZZLE;EmitVertex();\n"
    "      gl_Position=ClipP[PFC1].SWIZZLE;EmitVertex();\n"
    "      gl_Position=(MATRIX*ActOpposite).SWIZZLE;\n"
    "      EmitVertex();\n"
    "      EndPrimitive();\n"
    "      //back cap\n"
    "      gl_Position=ClipP[PBC0];EmitVertex();\n"
    "      gl_Position=ClipP[PBC1];EmitVertex();\n"
    "      gl_Position=MATRIX*vec4(ActOpposite.xyz*LIGHT.w-LIGHT.xyz,0);\n"
    "      EmitVertex();\n"
    "      EndPrimitive();\n"
    "    }else{\n"
    "      //front cap\n"
    "      gl_Position=ClipP[NFC0].SWIZZLE;EmitVertex();\n"
    "      gl_Position=ClipP[NFC1].SWIZZLE;EmitVertex();\n"
    "      gl_Position=(MATRIX*ActOpposite).SWIZZLE;\n"
    "      EmitVertex();\n"
    "      EndPrimitive();\n"
    "      //back cap\n"
    "      gl_Position=ClipP[NBC0];EmitVertex();\n"
    "      gl_Position=ClipP[NBC1];EmitVertex();\n"
    "      gl_Position=MATRIX*vec4(ActOpposite.xyz*LIGHT.w-LIGHT.xyz,0);\n"
    "      EmitVertex();\n"
    "      EndPrimitive();\n"
    "    }\n"
    "    #else//defined(CULL_SIDES) && defined(GENERATE_SIDES)\n"
    "    if(ActMultiplicity>0){\n"
    "      //front cap\n"
    "      gl_Position=(MATRIX*P[PFC0]).SWIZZLE;EmitVertex();\n"
    "      gl_Position=(MATRIX*P[PFC1]).SWIZZLE;EmitVertex();\n"
    "      gl_Position=(MATRIX*ActOpposite).SWIZZLE;\n"
    "      EmitVertex();\n"
    "      EndPrimitive();\n"
    "      //back cap\n"
    "      gl_Position=MATRIX*P[PBC0];EmitVertex();\n"
    "      gl_Position=MATRIX*P[PBC1];EmitVertex();\n"
    "      gl_Position=MATRIX*vec4(ActOpposite.xyz*LIGHT.w-LIGHT.xyz,0);\n"
    "      EmitVertex();\n"
    "      EndPrimitive();\n"
    "    }else{\n"
    "      //front cap\n"
    "      gl_Position=(MATRIX*P[NFC0]).SWIZZLE;EmitVertex();\n"
    "      gl_Position=(MATRIX*P[NFC1]).SWIZZLE;EmitVertex();\n"
    "      gl_Position=(MATRIX*ActOpposite).SWIZZLE;\n"
    "      EmitVertex();\n"
    "      EndPrimitive();\n"
    "      //back cap\n"
    "      gl_Position=MATRIX*P[NBC0];EmitVertex();\n"
    "      gl_Position=MATRIX*P[NBC1];EmitVertex();\n"
    "      gl_Position=MATRIX*vec4(ActOpposite.xyz*LIGHT.w-LIGHT.xyz,0);\n"
    "      EmitVertex();\n"
    "      EndPrimitive();\n"
    "    }\n"
    "    #endif//defined(CULL_SIDES) && defined(GENERATE_SIDES)\n"
    "  #endif//USE_STENCIL_VALUE_EXPORT\n"
    "  }\n"
    "#endif//GENERATE_CAPS\n"
    "\n"
    "#ifdef GENERATE_SIDES\n"
    "  #if defined(CULL_SIDES) && defined(GENERATE_CAPS)\n"
    "    if(NotCull)\n"
    "  #endif//defined(CULL_SIDES) && defined(GENERATE_CAPS)\n"
    "    Multiplicity+=ActMultiplicity;//sum up act multiplicities\n"
    "#endif//GENERATE_SIDES\n"
    "  }//for\n"
    "\n"
    "#ifdef GENERATE_SIDES\n"
    "  #ifdef USE_STENCIL_VALUE_EXPORT\n"
    "    if(Multiplicity!=0){\n"
    "    #ifdef CULL_SIDES\n"
    "      gMultiplicity=Multiplicity;gl_Position=ClipP[PS0];EmitVertex();\n"
    "      gMultiplicity=Multiplicity;gl_Position=ClipP[PS1];EmitVertex();\n"
    "      gMultiplicity=Multiplicity;gl_Position=ClipP[PS2];EmitVertex();\n"
    "      gMultiplicity=Multiplicity;gl_Position=ClipP[PS3];EmitVertex();\n"
    "    #else//CULL_SIDES\n"
    "      gMultiplicity=Multiplicity;gl_Position=MATRIX*P[PS0];\n"
    "      EmitVertex();\n"
    "      gMultiplicity=Multiplicity;gl_Position=MATRIX*P[PS1];\n"
    "      EmitVertex();\n"
    "      gMultiplicity=Multiplicity;gl_Position=MATRIX*P[PS2];\n"
    "      EmitVertex();\n"
    "      gMultiplicity=Multiplicity;gl_Position=MATRIX*P[PS3];\n"
    "      EmitVertex();\n"
    "    #endif//CULL_SIDES\n"
    "      EndPrimitive();\n"
    "    }\n"
    "  #else//USE_STENCIL_VALUE_EXPORT\n"
    "  if(Multiplicity>0){//more caps (CCW) frontface L\n"
    "    for(int i=0;i<Multiplicity;++i){\n"
    "    #ifdef CULL_SIDES\n"
    "      gl_Position=ClipP[PS0];EmitVertex();\n"
    "      gl_Position=ClipP[PS1];EmitVertex();\n"
    "      gl_Position=ClipP[PS2];EmitVertex();\n"
    "      gl_Position=ClipP[PS3];EmitVertex();\n"
    "    #else//CULL_SIDES\n"
    "      gl_Position=MATRIX*P[PS0];EmitVertex();\n"
    "      gl_Position=MATRIX*P[PS1];EmitVertex();\n"
    "      gl_Position=MATRIX*P[PS2];EmitVertex();\n"
    "      gl_Position=MATRIX*P[PS3];EmitVertex();\n"
    "    #endif//CULL_SIDES\n"
    "      EndPrimitive();\n"
    "    }\n"
    "  }\n"
    "  if(Multiplicity<0){//more caps (CCW) backface L\n"
    "    Multiplicity=-Multiplicity;\n"
    "    for(int i=0;i<Multiplicity;++i){\n"
    "    #ifdef CULL_SIDES\n"
    "      gl_Position=ClipP[NS0];EmitVertex();\n"
    "      gl_Position=ClipP[NS1];EmitVertex();\n"
    "      gl_Position=ClipP[NS2];EmitVertex();\n"
    "      gl_Position=ClipP[NS3];EmitVertex();\n"
    "    #else//CULL_SIDES\n"
    "      gl_Position=MATRIX*P[NS0];EmitVertex();\n"
    "      gl_Position=MATRIX*P[NS1];EmitVertex();\n"
    "      gl_Position=MATRIX*P[NS2];EmitVertex();\n"
    "      gl_Position=MATRIX*P[NS3];EmitVertex();\n"
    "    #endif//CULL_SIDES\n"
    "      EndPrimitive();\n"
    "    }\n"
    "  }\n"
    "  #endif//USE_STENCIL_VALUE_EXPORT\n"
    "#endif//GENERATE_CAPS\n"
    "}\n"
    "\n";
  const std::string VertexPrologue=
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Options:\n"
    "// if you define something, it will be applied.\n"
    "// if you don't define something, opposite will be applied.\n"
    "// Some defines has value that has to be set properly.\n"
    "// Version number has to be chosen by user, preprocessor\n"
    "// cannot do it (nothing useful can precede #version N P).\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n";

  const std::string VertexEpilogue=
    "\n"
    "// DO NOT CHANGE ANYTHING BELOW THIS COMMENT!!!\n"
    "// UNLESS, OF COURSE, YOU KNOW WHAT YOU ARE DOING.\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// TODO extensions and checks\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "#if MAX_MULTIPLICITY > 16\n"
    "  #error Max Multiplicity cannot exceed 16\n"
    "#endif\n"
    "\n"
    "#if MAX_MULTIPLICITY < 1\n"
    "  #error Max Multiplicity cannont be 0 or less\n"
    "#endif\n"
    "\n"
    "#define PASTER(x,y) x##y\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Inputs\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "//compute number of imput vertex attribs\n"
    "#ifdef UNIVERSAL\n"
    "  #define NUMBER_OF_INPUTS (MAX_MULTIPLICITY+2+1)\n"
    "#else//UNIVERSAL\n"
    "  #define NUMBER_OF_INPUTS (MAX_MULTIPLICITY+2)\n"
    "#endif//UNIVERSAL\n"
    "\n"
    "//declare inputs\n"
    "#ifdef USE_VERTEX_ARRAY\n"
    "  #ifdef USE_LAYOUTS\n"
    "    layout(location=0)in vec4 VERTEX_ATTRIB_NAME[NUMBER_OF_INPUTS];\n"
    "  #else\n"
    "    in vec4 VERTEX_ATTRIB_NAME[NUMBER_OF_INPUTS];\n"
    "  #endif\n"
    "#else//USE_VERTEX_ARRAY\n"
    "  #ifdef USE_LAYOUTS\n"
    "    #define DEF_INPUT(x,y) layout(location=y)in vec4 PASTER(x,y);\n"
    "  #else//USE_LAYOUTS\n"
    "    #define DEF_INPUT(x,y) in vec4 PASTER(x,y);\n"
    "  #endif//USE_LAYOUTS\n"
    "    //vertex A of an edge\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,0)\n"
    "    //vertex B of an edge\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,1)\n"
    "  #ifdef UNIVERSAL\n"
    "    //number of opposite vertices\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,2)\n"
    "    #if MAX_MULTIPLICITY>0\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,3)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>1\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,4)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>2\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,5)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>3\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,6)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>4\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,7)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>5\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,8)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>6\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,9)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>7\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,10)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>8\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,11)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>9\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,12)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>10\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,13)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>11\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,14)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>12\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,15)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>13\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,16)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>14\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,17)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>15\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,18)\n"
    "    #endif\n"
    "  #else//UNIVERSAL\n"
    "    #if MAX_MULTIPLICITY>0\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,2)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>1\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,3)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>2\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,4)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>3\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,5)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>4\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,6)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>5\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,7)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>6\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,8)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>7\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,9)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>8\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,10)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>9\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,11)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>10\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,12)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>11\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,13)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>12\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,14)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>13\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,15)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>14\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,16)\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>15\n"
    "DEF_INPUT(VERTEX_ATTRIB_NAME,17)\n"
    "    #endif\n"
    "  #endif//UNIVERSAL\n"
    "#endif//USE_VERTEX_ARRAY\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Outputs\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "#ifdef USE_ARRAY_TRANSFER\n"
    "out Opposite{vec4 Vertex[MAX_MULTIPLICITY];}O;\n"
    "#else\n"
    "  #define DEF_OUTPUT(x) out vec4 vOpposite##x;\n"
    "  #if MAX_MULTIPLICITY>0\n"
    "DEF_OUTPUT(0)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>1\n"
    "DEF_OUTPUT(1)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>2\n"
    "DEF_OUTPUT(2)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>3\n"
    "DEF_OUTPUT(3)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>4\n"
    "DEF_OUTPUT(4)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>5\n"
    "DEF_OUTPUT(5)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>6\n"
    "DEF_OUTPUT(6)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>7\n"
    "DEF_OUTPUT(7)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>8\n"
    "DEF_OUTPUT(8)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>9\n"
    "DEF_OUTPUT(9)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>10\n"
    "DEF_OUTPUT(10)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>11\n"
    "DEF_OUTPUT(11)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>12\n"
    "DEF_OUTPUT(12)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>13\n"
    "DEF_OUTPUT(13)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>14\n"
    "DEF_OUTPUT(14)\n"
    "  #endif\n"
    "  #if MAX_MULTIPLICITY>15\n"
    "DEF_OUTPUT(15)\n"
    "  #endif\n"
    "#endif//USE_ARRAY_TRANSFER\n"
    "\n"
    "out vec4 vVertexB;\n"
    "\n"
    "#ifdef UNIVERSAL\n"
    "out vec4 vNumberOfOppositeVertices;\n"
    "#endif\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Main function\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "void main(){\n"
    "\n"
    "#ifdef USE_VERTEX_ARRAY\n"
    "  #define DEF_FILLA(x) gl_Position=x[0];\n"
    "  #define DEF_FILLB(x) vVertexB=x[1];\n"
    "  #define DEF_FILLN(x) vNumberOfOppositeVertices=x[2];\n"
    "#else//USE_VERTEX_ARRAY\n"
    "  #define DEF_FILLA(x) gl_Position=PASTER(x,0);\n"
    "  #define DEF_FILLB(x) vVertexB=PASTER(x,1);\n"
    "  #define DEF_FILLN(x) vNumberOfOppositeVertices=PASTER(x,2);\n"
    "#endif//USE_VERTEX_ARRAY\n"
    "\n"
    "  //set vertex A\n"
    "  DEF_FILLA(VERTEX_ATTRIB_NAME)\n"
    "  //set vertex B\n"
    "  DEF_FILLB(VERTEX_ATTRIB_NAME)\n"
    "\n"
    "#ifdef UNIVERSAL\n"
    "  //set number of opposite vertices\n"
    "  DEF_FILLN(VERTEX_ATTRIB_NAME)\n"
    "#endif//UNIVERSAL\n"
    "\n"
    "//cycle can be used only when USE_VERTEX_ARRAY and\n"
    "//USE_ARRAY_TRANSFER\n"
    "//otherwise it has to be assign manually\n"
    "#if defined(USE_VERTEX_ARRAY) && defined(USE_ARRAY_TRANSFER)\n"
    "  #ifdef UNIVERSAL\n"
    "    #define DEF_FILL_RIGHT(x) x[3+o]\n"
    "  #else//UNIVERSAL\n"
    "    #define DEF_FILL_RIGHT(x) x[2+o]\n"
    "  #endif//UNIVERSAL\n"
    "  for(int o=0;o<MAX_MULTIPLICITY;++o)\n"
    "    O.Vertex[o]=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME);\n"
    "#else//defined(USE_VERTEX_ARRAY) && defined(USE_ARRAY_TRANSFER)\n"
    "  #ifdef USE_VERTEX_ARRAY\n"
    "    #ifdef USE_ARRAY_TRANSFER\n"
    "      #error this is Dormons fault\n"
    "    #else//USE_ARRAY_TRANSFER\n"
    "      #define DEF_FILL_LEFT(x)    vOpposite##x\n"
    "      #ifdef UNIVERSAL\n"
    "        #define DEF_FILL_RIGHT(x,y) x[y]\n"
    "      #else//UNIVERSAL\n"
    "        #define DEF_FILL_RIGHT(x,y) PASTER(x,[y])\n"
    "      #endif\n"
    "    #endif//USE_ARRAY_TRANSFER\n"
    "  #else//USE_VERTEX_ARRAY\n"
    "    #ifdef USE_ARRAY_TRANSFER\n"
    "      #define DEF_FILL_LEFT(x)    O.Vertex[x]\n"
    "      #define DEF_FILL_RIGHT(x,y) PASTER(x,y)\n"
    "    #else//USE_ARRAY_TRANSFER\n"
    "      #define DEF_FILL_LEFT(x)    vOpposite##x\n"
    "      #define DEF_FILL_RIGHT(x,y) PASTER(x,y)\n"
    "    #endif//USE_ARRAY_TRANSFER\n"
    "  #endif//USE_VERTEX_ARRAY\n"
    "\n"
    "  //assign all attribs\n"
    "  #ifdef UNIVERSAL\n"
    "    #if MAX_MULTIPLICITY>0\n"
    "  DEF_FILL_LEFT(0)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,3);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>1\n"
    "  DEF_FILL_LEFT(1)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,4);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>2\n"
    "  DEF_FILL_LEFT(2)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,5);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>3\n"
    "  DEF_FILL_LEFT(3)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,6);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>4\n"
    "  DEF_FILL_LEFT(4)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,7);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>5\n"
    "  DEF_FILL_LEFT(5)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,8);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>6\n"
    "  DEF_FILL_LEFT(6)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,9);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>7\n"
    "  DEF_FILL_LEFT(7)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,10);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>8\n"
    "  DEF_FILL_LEFT(8)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,11);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>9\n"
    "  DEF_FILL_LEFT(9)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,12);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>10\n"
    "  DEF_FILL_LEFT(10)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,13);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>11\n"
    "  DEF_FILL_LEFT(11)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,14);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>12\n"
    "  DEF_FILL_LEFT(12)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,15);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>13\n"
    "  DEF_FILL_LEFT(13)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,16);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>14\n"
    "  DEF_FILL_LEFT(14)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,17);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>15\n"
    "  DEF_FILL_LEFT(15)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,18);\n"
    "    #endif\n"
    "  #else//UNIVERSAL\n"
    "    #if MAX_MULTIPLICITY>0\n"
    "  DEF_FILL_LEFT(0)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,2);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>1\n"
    "  DEF_FILL_LEFT(1)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,3);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>2\n"
    "  DEF_FILL_LEFT(2)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,4);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>3\n"
    "  DEF_FILL_LEFT(3)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,5);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>4\n"
    "  DEF_FILL_LEFT(4)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,6);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>5\n"
    "  DEF_FILL_LEFT(5)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,7);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>6\n"
    "  DEF_FILL_LEFT(6)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,8);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>7\n"
    "  DEF_FILL_LEFT(7)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,9);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>8\n"
    "  DEF_FILL_LEFT(8)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,10);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>9\n"
    "   DEF_FILL_LEFT(9)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,11);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>10\n"
    "  DEF_FILL_LEFT(10)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,12);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>11\n"
    "  DEF_FILL_LEFT(11)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,13);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>12\n"
    "  DEF_FILL_LEFT(12)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,14);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>13\n"
    "  DEF_FILL_LEFT(13)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,15);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>14\n"
    "  DEF_FILL_LEFT(14)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,16);\n"
    "    #endif\n"
    "    #if MAX_MULTIPLICITY>15\n"
    "  DEF_FILL_LEFT(15)=DEF_FILL_RIGHT(VERTEX_ATTRIB_NAME,17);\n"
    "    #endif\n"
    "  #endif//UNIVERSAL\n"
    "#endif//defined(USE_VERTEX_ARRAY) && defined(USE_ARRAY_TRANSFER)\n"
    "}\n";
  const std::string FragmentPrologue=
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Options:\n"
    "// if you define something, it will be applied.\n"
    "// if you don't define something, opposite will be applied.\n"
    "// Some defines has value that has to be set properly.\n"
    "// Version number has to be chosen by user, preprocessor\n"
    "// cannot do it (nothing useful can precede #version N P).\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n";
  const std::string FragmentEpilogue=
    "\n"
    "// DO NOT CHANGE ANYTHING BELOW THIS COMMENT!!!\n"
    "//UNLESS, OF COURSE, YOU KNOW WHAT YOU ARE DOING.\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// TODO extensions and checks\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "#ifdef USE_STENCIL_VALUE_EXPORT\n"
    "  #extension GL_ARB_shader_stencil_export:enable\n"
    "#endif\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Inputs\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "#ifdef USE_STENCIL_VALUE_EXPORT\n"
    "flat in int gMultiplicity;\n"
    "#endif//USE_STENCIL_VALUE_EXPORT\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Outputs from geometry shader\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "#ifdef VISUALIZE\n"
    "  #ifdef USE_LAYOUTS\n"
    "layout(location=0)out vec4 fColor;\n"
    "  #else//USE_LAYOUTS\n"
    "out vec4 fColor;\n"
    "  #endif//USE_LAYOUTS\n"
    "#endif//VISUALIZE\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "// Main function\n"
    "/////////////////////////////////////////////////////////////////////\n"
    "\n"
    "void main(){\n"
    "#ifdef USE_STENCIL_VALUE_EXPORT\n"
    "  gl_FragStencilValueAMD=gMultiplicity; \n"
    "#endif//USE_STENCIL_VALUE_EXPORT\n"
    "\n"
    "#ifdef VISUALIZE\n"
    "  if(gl_FrontFacing)fColor=vec4(0,1,0,1);\n"
    "  else fColor=vec4(1,0,0,1);\n"
    "#endif//VISUALIZE\n"
    "}\n";

  std::string WLC(bool Write){
    if(!Write)return"//";
    return"";
  }

  std::string getVertex  (STemplate T){
    std::stringstream Result;//resulting vertex shader
    Result<<"#version "<<T.Version
      <<" "<<TranslateShaderProfile(T.Profile)<<"\n";

    Result<<VertexPrologue;

    Result<<"//generate universal shader - define/don't define\n";
    Result<<WLC(T.Universal)<<"#define UNIVERSAL\n";
    Result<<"//use arrays for transfer - define/don't define\n";
    Result<<WLC(T.UseVS2GSArray)<<"#define USE_ARRAY_TRANSFER\n";
    Result<<"//use vertex array - define/don't define\n";
    Result<<WLC(T.UseVertexArray)<<"#define USE_VERTEX_ARRAY\n";
    Result<<"//use layouts - define/don't define\n";
    Result<<WLC(T.UseLayouts)<<"#define USE_LAYOUTS\n";
    Result<<"//set input vertex attrib name - set value\n";
    Result<<"#define VERTEX_ATTRIB_NAME "<<T.VertexAttribName<<"\n";
    Result<<"//maximal number of opposite vertices - set value\n";
    Result<<"#define MAX_MULTIPLICITY "<<T.MaxMultiplicity<<"\n";

    Result<<VertexEpilogue;

    return Result.str();
  }

  std::string getGeometry(STemplate T){
    std::stringstream Result;//resulting geometry shader
    Result<<"#version "<<T.Version
      <<" "<<TranslateShaderProfile(T.Profile)<<"\n";

    Result<<GeometryPrologue;

    Result<<"//toggle determinism - define/don't define\n";
    Result<<WLC(T.Deterministic)<<"#define DETERMINISTIC\n";
    Result<<"//toggle usage of reference edge - define/don't define\n";
    Result<<WLC(T.ReferenceEdge)<<"#define REFERENCE_EDGE\n";
    Result<<"//generate universal shader - define/don't define\n";
    Result<<WLC(T.Universal)<<"#define UNIVERSAL\n";
    Result<<"//use arrays for transfer - define/don't define\n";
    Result<<WLC(T.UseVS2GSArray)<<"#define USE_ARRAY_TRANSFER\n";
    Result<<"//use extension: GL_AMD_shader_stencil_value_export\n";
    Result<<"//define/not define \n";
    Result<<WLC(T.UseStencilValueExport)<<"#define USE_STENCIL_VALUE_EXPORT\n";
    Result<<"//front faces are CCW - define/don't define\n";
    Result<<WLC(T.CCWIsFrontFace)<<"#define CCW_IS_FRONT_FACE\n";
    Result<<"//front faces are inside Shadow volume - define/don't define\n";
    Result<<WLC(T.FrontFaceInside)<<"#define FRONT_FACE_INSIDE\n";
    Result<<"//toggle usage of culling of shadow volume sides if \n";
    Result<<"//they are invisible\n";
    Result<<WLC(T.CullSides)<<"#define CULL_SIDES\n";
    Result<<"//shift front cap to infinity - define/don't define\n";
    Result<<WLC(T.FrontCapToInfinity)<<"#define FRONT_CAP_TO_INFINITY\n";
    Result<<"//shader will generate sides - define/don't define\n";
    Result<<WLC(T.GenerateSides)<<"#define GENERATE_SIDES\n";
    Result<<"//shader will generate caps - define/don't define\n";
    Result<<WLC(T.GenerateCaps)<<"#define GENERATE_CAPS\n";
    Result<<"//name of matrix - define/don't define (will use fixed mvp)\n";
    Result<<WLC(!(T.Matrix==""||T.Matrix=="gl_ModelViewProjectionMatrix"))
      <<"#define MATRIX "<<T.Matrix<<"\n";
    Result<<"//maximal number of opposite vertices - set value\n";
    Result<<"#define MAX_MULTIPLICITY "<<T.MaxMultiplicity<<"\n";
    Result<<"//name of light - set value\n";
    Result<<"#define LIGHT "<<T.LightUniform<<"\n";

    Result<<GeometryEpilogue;
    return Result.str();
  }

  std::string getFragment(STemplate T){
    std::stringstream Result;//resulting vertex shader
    Result<<"#version "<<T.Version
      <<" "<<TranslateShaderProfile(T.Profile)<<"\n";

    Result<<FragmentPrologue;

    Result<<"//use extension: GL_AMD_shader_stencil_value_export\n";
    Result<<"//define/not define \n";
    Result<<WLC(T.UseStencilValueExport)<<"#define USE_STENCIL_VALUE_EXPORT\n";
    Result<<"//use layouts - define/don't define\n";
    Result<<WLC(T.UseLayouts)<<"#define USE_LAYOUTS\n";
    Result<<"//visualize front and back faces with different color\n";
    Result<<WLC(T.Visualize)<<"#define VISUALIZE\n";

    Result<<FragmentEpilogue;

    return Result.str();
  }

  STemplate getTemplate(unsigned Number){
    STemplate T;
    bool*Attrib=(bool*)&T;
    unsigned NumBoolean=13;//change properly
    for(unsigned b=0;b<NumBoolean;++b)
      Attrib[b]=(bool)((Number>>b)&1);
    if((Number>>NumBoolean)&1)T.Matrix="mvp";
    else T.Matrix="gl_ModelViewProjectionMatrix";
    if(!T.GenerateSides&&!T.GenerateCaps)
      T.GenerateSides=T.GenerateCaps=true;
    T.Version=430;
    T.Profile=COMPATIBILITY;
    T.MaxMultiplicity=3;
    T.LightUniform="LightPosition";
    return T;
  }

}
